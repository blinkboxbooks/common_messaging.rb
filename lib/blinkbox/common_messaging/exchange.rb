module Blinkbox
  module CommonMessaging
    class Exchange
      extend Forwardable
      def_delegators :@exchange, :on_return

      # A wrapped class for Bunny::Exchange. Wrapped so we can take care of message validation and header 
      # conventions in the blinkbox Books format.
      #
      # @param [String] exchange_name The name of the Exchange to connect to.
      # @param [String] facility The name of the app or service (we've adopted the GELF naming term across ruby)
      # @param [String] facility_version The version of the app or service which sent the message.
      # @raise [Bunny::NotFound] If the exchange does not exist.
      def initialize(exchange_name, facility: File.basename($0, '.rb'), facility_version: "0.0.0-unknown")
        @app_id = "#{facility}:v#{facility_version}"
        connection = CommonMessaging.connection
        channel = connection.create_channel
        channel.confirm_select
        @exchange = channel.headers(
          exchange_name,
          durable: true,
          auto_delete: false,
          passive: true
        )
      end

      # Publishes a message to the exchange with blinkbox Books default message headers and properties.
      #
      # Worth noting that because of a quirk of the RabbitMQ Headers Exchange you cannot route on properties
      # so, in order to facilitate routing on content-type, that key is written to the headers by default as
      # well as to the properties.
      #
      # @param [Blinkbox::CommonMessaging::JsonSchemaPowered, String] data The information which will be sent as the payload of the message. An instance of any class generated by Blinkbox::CommonMessaging.init_from_schema_at while :validate is true, or a String if false.
      # @param [Hash] headers A hash of string keys and string values which will be sent as headers with the message. Used for matching.
      # @param [Array<String>] message_id_chain Optional. The message_id_chain of the message which was received in order to prompt this one.
      # @param [Boolean] confirm Will block this method until the MQ server has confirmed the message has been persisted and routed.
      # @param [Boolean] validate if false will relax the constraint that the inbound data must be a JsonSchemaPowered object.
      #Â @return [String] The correlation_id of the message which was delivered.
      def publish(data, headers: {}, message_id_chain: [], confirm: true, validate: true)
        raise ArgumentError, "All published messages must be validated. Please see Blinkbox::CommonMessaging.init_from_schema_at for details." if validate && !data.class.included_modules.include?(JsonSchemaPowered)
        raise ArgumentError, "message_id_chain must be an array of strings" unless message_id_chain.is_a?(Array)

        message_id = generate_message_id
        new_message_id_chain = message_id_chain.dup << message_id
        correlation_id = new_message_id_chain.first

        headers = headers.merge!("message_id_chain" => new_message_id_chain)
        options = {}

        if data.respond_to?(:content_type)
          hd = Blinkbox::CommonMessaging::HeaderDetectors.new(data)
          headers = hd.modified_headers(headers)
          # We have to do both of these because of RabbitMQ's weird header exchange protocol
          headers["content-type"] = data.content_type 
          options[:content_type] = data.content_type
          data = data.to_json
        end

        options.merge!(
          persistent: true,
          correlation_id: correlation_id,
          message_id: message_id,
          app_id: @app_id,
          timestamp: Time.now.to_i,
          headers: headers
        )
        @exchange.publish(data, options)

        if confirm && !@exchange.channel.wait_for_confirms
          message_id = @exchange.channel.nacked_set.first
          raise UndeliverableMessageError, "Message #{message_id} was returned as undeliverable by RabbitMQ."
        end

        message_id
      end

      private

      def generate_message_id
        SecureRandom.hex(8) # 8 generates a 16 byte string
      end
    end
  end
end